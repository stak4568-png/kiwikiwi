# 코드 통합 분석 보고서

## 제공된 코드 분석

```csharp
if (visible)
{
    Vector3 dest = GameBoard.Get().RaycastMouseBoard();
    transform.position = dest;
}
```

### 코드의 목적
- `visible`이 true일 때 마우스 위치를 보드 좌표로 변환하여 transform을 이동
- UI 요소가 마우스를 따라다니는 기능 구현

### 특징
- 간단하고 직관적인 구조
- GameBoard 싱글톤을 통한 보드 좌표 변환
- Update 메서드에서 사용 가능

---

## 프로젝트 기존 코드와의 비교

### 1. CombatArrow.cs (유사한 패턴)
```csharp
void Update()
{
    if (!gameObject.activeSelf) return;
    // 마우스 위치 추적
    UpdateBezierArrow(mousePos);
}
```
- **차이점**: CombatArrow는 베지어 곡선을 그리는 복잡한 로직
- **공통점**: activeSelf/visible 체크 후 마우스 추적

### 2. Draggable.cs (다른 접근)
```csharp
public void OnDrag(PointerEventData eventData)
{
    this.transform.position = eventData.position;
}
```
- **차이점**: EventSystem의 eventData.position 사용 (스크린 좌표)
- **차이점**: 드래그 이벤트 기반 (Update 아님)

---

## 통합 방안

### ✅ 방안 1: 범용 MouseFollower 컴포넌트 생성 (권장)

**장점:**
- 재사용 가능한 범용 컴포넌트
- 여러 UI 요소에 적용 가능
- 부드러운 이동, 오프셋 등 추가 기능 확장 가능

**사용 예시:**
- 카드 프리뷰 팝업
- 툴팁
- 인디케이터
- 드래그 중인 카드의 위치 표시

**구현:** `MouseFollower.cs` 생성 완료

---

### ✅ 방안 2: CombatArrow 개선

현재 CombatArrow는 화살표 끝부분만 마우스를 따라가는데, 제공된 코드를 활용하여:
- 보드 좌표로 정확한 위치 계산
- 보드 경계 내에서만 작동하도록 제한

**적용 위치:** `CombatArrow.Update()` 메서드

---

### ✅ 방안 3: Draggable 개선

현재 Draggable은 `eventData.position`을 직접 사용하는데, 보드 좌표로 변환하면:
- 보드 경계를 벗어나지 않도록 제한
- 더 정확한 위치 계산

**적용 위치:** `Draggable.OnDrag()` 메서드

---

## 통합 우선순위

### 1순위: MouseFollower 컴포넌트
- 범용적이고 재사용 가능
- 즉시 사용 가능
- 다른 컴포넌트에 의존하지 않음

### 2순위: CombatArrow 개선
- 기존 기능 유지하면서 보드 좌표 변환 추가
- 공격 화살표의 정확도 향상

### 3순위: Draggable 개선
- 기존 동작 방식과 충돌 가능성
- 테스트 필요

---

## 사용 예시

### 예시 1: 카드 프리뷰 팝업
```csharp
public class CardPreview : MonoBehaviour
{
    private MouseFollower mouseFollower;
    
    void Start()
    {
        mouseFollower = GetComponent<MouseFollower>();
    }
    
    public void ShowPreview()
    {
        mouseFollower.SetVisible(true);
    }
    
    public void HidePreview()
    {
        mouseFollower.SetVisible(false);
    }
}
```

### 예시 2: 툴팁
```csharp
public class Tooltip : MonoBehaviour
{
    public MouseFollower follower;
    public Vector3 tooltipOffset = new Vector3(10, 10, 0);
    
    public void Show()
    {
        follower.offset = tooltipOffset;
        follower.SetVisible(true);
    }
}
```

---

## 주의사항

1. **GameBoard 초기화**: GameBoard.Get()이 null을 반환하지 않도록 보장 필요
2. **성능**: Update에서 매 프레임 호출되므로 최적화 필요
3. **좌표계**: RectTransform vs Transform - UI 요소는 RectTransform 사용 권장
4. **레이어 순서**: 마우스를 따라다니는 요소는 다른 UI 위에 표시되어야 함

---

## 결론

제공된 코드는 **프로젝트에 통합 가능**하며, 다음과 같이 활용할 수 있습니다:

1. ✅ **MouseFollower 컴포넌트**로 범용화 (생성 완료)
2. ✅ **CombatArrow 개선**에 활용 가능
3. ✅ **새로운 UI 요소**에 즉시 적용 가능

코드는 간단하고 효율적이며, 기존 프로젝트 구조와 잘 맞습니다.

